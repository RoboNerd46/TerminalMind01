<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Stream of Consciousness - 286 Terminal</title>
    <style>
        /* Basic Reset & Font */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #00ff41; /* Green terminal text */
            font-family: 'Courier New', monospace;
            overflow: hidden; /* Hide scrollbars */
        }

        /* Main Layout */
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Controls Panel */
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            border: 1px solid #003300;
        }

        .controls button {
            background: #001100;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .controls button:hover {
            background: #002200;
            box-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #000500;
            box-shadow: none;
        }

        /* Status Indicators */
        .streaming-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            background: #ff0000; /* Red for disconnected/off */
            animation: pulse 1s infinite;
        }

        .streaming-indicator.connected {
            background: #00ff00; /* Green for connected */
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .status {
            margin-bottom: 10px;
            font-size: 11px;
            border-bottom: 1px solid #003300;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        /* Terminal Display Area */
        #terminal {
            position: relative;
            background: #000800; /* Darker green-black background */
            flex: 1; /* Takes remaining space */
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* For crisp pixel art style */
        }

        /* CRT Effects */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through */
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 65, 0.03) 50% /* Very subtle green line */
            );
            background-size: 100% 4px; /* Height of each scanline */
            animation: scanlines 0.1s linear infinite; /* Subtle vertical movement */
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        .crt-glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-shadow:
                inset 0 0 100px rgba(0, 255, 65, 0.1), /* Inner glow */
                inset 0 0 200px rgba(0, 255, 65, 0.05); /* Larger, softer glow */
            border-radius: 20px; /* Slight screen curvature effect */
        }

        /* Log Display */
        .log-display {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff41;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            border: 1px solid #003300;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }

        /* Configuration Panel */
        .config-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 20px;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            z-index: 2000; /* On top of everything */
            display: none; /* Hidden by default */
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .config-panel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #00ff65;
            text-shadow: 0 0 10px #00ff65;
            border-bottom: 1px dashed #003300;
            padding-bottom: 10px;
        }

        .config-row {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .config-panel label {
            flex-basis: 60%;
            text-align: left;
        }

        .config-panel input[type="number"],
        .config-panel select {
            background: #001100;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 5px;
            font-family: inherit;
            border-radius: 3px;
            flex-basis: 35%;
        }

        .config-panel input[type="checkbox"] {
            margin-left: auto; /* Push checkbox to the right */
        }

        .config-panel button {
            background: #001100;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .config-panel button:hover {
            background: #002200;
            box-shadow: 0 0 5px #00ff41;
        }

        /* Debug Information */
        .debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff41;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            border: 1px solid #003300;
            max-width: 300px;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }

        /* Messages (optional, for status popups etc) */
        .error-message {
            color: #ff4444;
            background: rgba(64, 0, 0, 0.8);
            border: 1px solid #ff4444;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }

        .success-message {
            color: #44ff44;
            background: rgba(0, 64, 0, 0.8);
            border: 1px solid #44ff44;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }

        /* Utility class */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="status">
                <div class="status-row">
                    <span>Status:</span>
                    <span id="status">Ready</span>
                </div>
                <div class="status-row">
                    <span>Frames:</span>
                    <span id="frameCount">0</span>
                </div>
                <div class="status-row">
                    <span>Cycle:</span>
                    <span id="cycleCount">0</span>
                </div>
                <div class="status-row">
                    <span>WS:</span>
                    <span id="wsStatus">Disconnected</span>
                </div>
                <div class="status-row">
                    <span>Stream:</span>
                    <span id="streamStatus">Off</span>
                </div>
                <div class="status-row">
                    <span>Sent:</span>
                    <span id="framesSent">0</span>
                </div>
            </div>
            <button id="testBtn">üîß Test FFmpeg</button>
            <button id="configBtn">‚öôÔ∏è Config</button>
            <button id="startBtn" disabled>‚ñ∂Ô∏è Start Stream</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
            <button id="streamBtn" disabled>üî¥ Start YouTube Stream</button>
            <button id="downloadBtn" disabled>üíæ Download Log</button>
            <button id="fullscreenBtn">üñ•Ô∏è Fullscreen</button>
        </div>

        <div id="terminal">
            <canvas id="canvas"></canvas>
            <div class="scanlines"></div>
            <div class="crt-glow"></div>
        </div>

        <div class="log-display" id="logDisplay">
            <div>üß† AI Consciousness Terminal v1.1</div>
            <div>üîÑ Keep-alive system enabled</div>
            <div>üì° Enhanced YouTube streaming</div>
            <div>Ready to initialize neural pathways...</div>
        </div>

        <div class="debug-info" id="debugInfo" style="display: none;">
            <div><strong>Debug Information</strong></div>
            <div>WebSocket: <span id="debugWS">-</span></div>
            <div>FFmpeg: <span id="debugFFmpeg">-</span></div>
            <div>Frame Rate: <span id="debugFPS">-</span></div>
            <div>Buffer: <span id="debugBuffer">-</span></div>
        </div>
    </div>

    <div class="config-panel" id="configPanel">
        <h2>üñ•Ô∏è Terminal Configuration</h2>

        <div class="config-row">
            <label for="durationInput">Stream Duration (minutes):</label>
            <input type="number" id="durationInput" value="5" min="1" max="60">
        </div>

        <div class="config-row">
            <label for="cyclesInput">Q&A Cycles:</label>
            <input type="number" id="cyclesInput" value="15" min="5" max="50">
        </div>

        <div class="config-row">
            <label for="speedInput">Typing Speed:</label>
            <select id="speedInput">
                <option value="0.03">Very Fast</option>
                <option value="0.06" selected>Fast</option>
                <option value="0.1">Normal</option>
                <option value="0.15">Slow</option>
                <option value="0.2">Very Slow</option>
            </select>
        </div>

        <div class="config-row">
            <label for="widthInput">Terminal Width (chars):</label>
            <input type="number" id="widthInput" value="70" min="40" max="120">
        </div>

        <div class="config-row">
            <label for="fontSizeInput">Font Size:</label>
            <select id="fontSizeInput">
                <option value="12">Small</option>
                <option value="16" selected>Medium</option>
                <option value="20">Large</option>
                <option value="24">Extra Large</option>
            </select>
        </div>

        <div class="config-row">
            <label for="thinkingInput">Show Thinking Indicator:</label>
            <input type="checkbox" id="thinkingInput" checked>
        </div>

        <div class="config-row">
            <label for="enableStreamingInput">YouTube Streaming:</label>
            <input type="checkbox" id="enableStreamingInput" checked>
        </div>

        <div class="config-row">
            <label for="debugModeInput">Debug Mode:</label>
            <input type="checkbox" id="debugModeInput">
        </div>

        <div style="text-align: center; margin-top: 20px;">
            <button id="saveConfigBtn">üíæ Save & Close</button>
            <button id="cancelConfigBtn">‚ùå Cancel</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get references to DOM elements ---
            const statusSpan = document.getElementById('status');
            const frameCountSpan = document.getElementById('frameCount');
            const cycleCountSpan = document.getElementById('cycleCount');
            const wsStatusSpan = document.getElementById('wsStatus');
            const streamStatusSpan = document.getElementById('streamStatus');
            const framesSentSpan = document.getElementById('framesSent');

            // Control buttons
            const testBtn = document.getElementById('testBtn');
            const configBtn = document.getElementById('configBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const streamBtn = document.getElementById('streamBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            // Config panel elements
            const configPanel = document.getElementById('configPanel');
            const saveConfigBtn = document.getElementById('saveConfigBtn');
            const cancelConfigBtn = document.getElementById('cancelConfigBtn');
            const durationInput = document.getElementById('durationInput');
            const cyclesInput = document.getElementById('cyclesInput');
            const speedInput = document.getElementById('speedInput');
            const widthInput = document.getElementById('widthInput');
            const fontSizeInput = document.getElementById('fontSizeInput');
            const thinkingInput = document.getElementById('thinkingInput');
            const enableStreamingInput = document.getElementById('enableStreamingInput');
            const debugModeInput = document.getElementById('debugModeInput');

            // Debug info display
            const debugInfo = document.getElementById('debugInfo');
            const debugWS = document.getElementById('debugWS');
            const debugFFmpeg = document.getElementById('debugFFmpeg');
            const debugFPS = document.getElementById('debugFPS');
            const debugBuffer = document.getElementById('debugBuffer');

            // Canvas and context (for terminal display)
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let terminalWidth = parseInt(widthInput.value); // Characters wide
            let terminalHeight; // Characters tall, will be calculated
            let fontSize = parseInt(fontSizeInput.value);
            let charWidth, charHeight; // Pixel dimensions of a character

            // --- WebSocket Setup ---
            let ws;
            let pingInterval; // Declare pingInterval here

            const connectWebSocket = () => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsURL = `${protocol}//${window.location.host}`;
                ws = new WebSocket(wsURL);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    wsStatusSpan.textContent = 'Connected';
                    wsStatusSpan.classList.add('connected');
                    // Enable/disable buttons as appropriate on connection
                    startBtn.disabled = false;
                    testBtn.disabled = false;
                    // stopBtn.disabled = true; // Still disabled until stream starts
                    streamBtn.disabled = false; // Enable if YouTube streaming is ready

                    // Start sending a ping every few seconds (e.g., 5 seconds)
                    pingInterval = setInterval(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 5000); // Send ping every 5 seconds
                };

                ws.onmessage = (event) => {
                    // console.log('Received:', event.data); // Uncomment for verbose logging
                    // Handle incoming messages from the server (e.g., terminal output, status updates)
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'log') {
                            appendLog(data.message);
                        } else if (data.type === 'status') {
                            statusSpan.textContent = data.message;
                        } else if (data.type === 'frameUpdate') {
                            frameCountSpan.textContent = data.frameCount;
                            framesSentSpan.textContent = data.framesSent; // If server sends frames sent count
                        } else if (data.type === 'cycleUpdate') {
                            cycleCountSpan.textContent = data.cycleCount;
                        } else if (data.type === 'streamStatus') {
                            streamStatusSpan.textContent = data.message;
                            if (data.message === 'Live') {
                                startBtn.disabled = true;
                                stopBtn.disabled = false;
                                streamBtn.disabled = true;
                            } else if (data.message === 'Off' || data.message === 'Error') {
                                startBtn.disabled = false;
                                stopBtn.disabled = true;
                                streamBtn.disabled = false;
                            }
                        }
                        // For debug info
                        if (data.debug) {
                            debugWS.textContent = data.debug.ws || debugWS.textContent;
                            debugFFmpeg.textContent = data.debug.ffmpeg || debugFFmpeg.textContent;
                            debugFPS.textContent = data.debug.fps || debugFPS.textContent;
                            debugBuffer.textContent = data.debug.buffer || debugBuffer.textContent;
                        }
                        if (data.terminalContent) {
                            drawTerminal(data.terminalContent);
                        }
                    } catch (e) {
                        console.error("Error parsing WebSocket message:", e, event.data);
                        appendLog(`WS Error: Malformed message received.`);
                    }
                };

                ws.onclose = () => {
                    console.log('WebSocket disconnected. Attempting to reconnect...');
                    wsStatusSpan.textContent = 'Disconnected';
                    wsStatusSpan.classList.remove('connected');
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                    testBtn.disabled = true;
                    streamBtn.disabled = true;

                    // Clear the ping interval when connection closes
                    if (pingInterval) {
                        clearInterval(pingInterval);
                    }

                    setTimeout(connectWebSocket, 3000); // Attempt to reconnect every 3 seconds
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    wsStatusSpan.textContent = 'Error';
                    wsStatusSpan.classList.remove('connected');

                    // Clear the ping interval on error too
                    if (pingInterval) {
                        clearInterval(pingInterval);
                    }
                };
            };

            // --- Terminal Drawing Logic ---
            const resizeCanvas = () => {
                const terminalDiv = document.getElementById('terminal');
                canvas.width = terminalDiv.clientWidth;
                canvas.height = terminalDiv.clientHeight;

                // Set font properties to measure character size
                ctx.font = `${fontSize}px 'Courier New', monospace`;
                // Measure text metrics once for character width/height
                const metrics = ctx.measureText('M');
                charWidth = metrics.width;
                // A common heuristic for line height in monospace fonts is font size
                charHeight = fontSize;

                terminalWidth = Math.floor(canvas.width / charWidth);
                terminalHeight = Math.floor(canvas.height / charHeight);

                // Re-draw current content if available, to adapt to new size
                // (This assumes you have a variable holding the current terminal content)
                // if (currentTerminalLines) {
                //     drawTerminal(currentTerminalLines);
                // }
            };

            const drawTerminal = (lines) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff41'; // Green text
                ctx.font = `${fontSize}px 'Courier New', monospace`;

                lines.forEach((line, index) => {
                    // Ensure lines don't go past canvas height
                    if ((index + 1) * charHeight <= canvas.height) {
                        ctx.fillText(line, 0, (index + 1) * charHeight);
                    }
                });
            };

            // --- Log Display ---
            const logDisplay = document.getElementById('logDisplay');
            const appendLog = (message) => {
                const div = document.createElement('div');
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logDisplay.appendChild(div);
                logDisplay.scrollTop = logDisplay.scrollHeight; // Scroll to bottom
            };

            // --- Initial setup calls ---
            resizeCanvas(); // Set initial canvas size and char dimensions
            window.addEventListener('resize', resizeCanvas); // Adjust canvas on window resize
            connectWebSocket(); // Establish WebSocket connection on load

            // --- Button Event Listeners ---

            // Config Button
            configBtn.addEventListener('click', () => {
                configPanel.style.display = 'block';
                // Load current values into config inputs from localStorage or defaults
                durationInput.value = localStorage.getItem('duration') || '5';
                cyclesInput.value = localStorage.getItem('cycles') || '15';
                speedInput.value = localStorage.getItem('speed') || '0.06';
                widthInput.value = localStorage.getItem('terminalWidth') || '70';
                fontSizeInput.value = localStorage.getItem('fontSize') || '16';
                thinkingInput.checked = localStorage.getItem('showThinking') === 'true';
                enableStreamingInput.checked = localStorage.getItem('enableStreaming') === 'true';
                debugModeInput.checked = localStorage.getItem('debugMode') === 'true';
            });

            // Save Config Button
            saveConfigBtn.addEventListener('click', () => {
                configPanel.style.display = 'none';
                // Save current values to localStorage
                localStorage.setItem('duration', durationInput.value);
                localStorage.setItem('cycles', cyclesInput.value);
                localStorage.setItem('speed', speedInput.value);
                localStorage.setItem('terminalWidth', widthInput.value);
                localStorage.setItem('fontSize', fontSizeInput.value);
                localStorage.setItem('showThinking', thinkingInput.checked);
                localStorage.setItem('enableStreaming', enableStreamingInput.checked);
                localStorage.setItem('debugMode', debugModeInput.checked);

                // Apply relevant changes instantly
                fontSize = parseInt(fontSizeInput.value);
                resizeCanvas(); // Recalculate based on new font size and update canvas
                terminalWidth = parseInt(widthInput.value); // Apply new terminal character width

                if (debugModeInput.checked) {
                    debugInfo.style.display = 'block';
                } else {
                    debugInfo.style.display = 'none';
                }

                console.log('Config saved and applied!');
                appendLog('Configuration updated.');

                // Optionally send config to server if needed (e.g., if server needs to adjust its behavior)
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'configUpdate',
                        duration: parseInt(durationInput.value),
                        cycles: parseInt(cyclesInput.value),
                        typingSpeed: parseFloat(speedInput.value),
                        terminalWidth: parseInt(widthInput.value),
                        fontSize: parseInt(fontSizeInput.value), // Send font size for server-side calculations if needed
                        showThinking: thinkingInput.checked,
                        enableStreaming: enableStreamingInput.checked,
                        debugMode: debugModeInput.checked
                    }));
                }
            });

            // Cancel Config Button
            cancelConfigBtn.addEventListener('click', () => {
                configPanel.style.display = 'none';
                console.log('Config cancelled.');
            });

            // Test FFmpeg Button
            testBtn.addEventListener('click', async () => {
                appendLog('Testing FFmpeg...');
                try {
                    const response = await fetch('/api/test-ffmpeg');
                    const data = await response.text();
                    appendLog(`FFmpeg Test: ${data}`);
                    console.log(`FFmpeg Test: ${data}`);
                } catch (error) {
                    appendLog(`FFmpeg Test Error: ${error.message}`);
                    console.error('FFmpeg Test Error:', error);
                }
            });

            // Start Stream Button
            startBtn.addEventListener('click', () => {
                appendLog('Initiating AI Consciousness stream...');
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'startStream' }));
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    streamBtn.disabled = true; // Disable YouTube stream until main stream is ready/live
                } else {
                    appendLog('WebSocket not connected. Cannot start stream.');
                    console.warn('WebSocket not connected.');
                }
            });

            // Stop Button
            stopBtn.addEventListener('click', () => {
                appendLog('Stopping AI Consciousness stream...');
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'stopStream' }));
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    streamBtn.disabled = false; // Re-enable YouTube stream button
                } else {
                    appendLog('WebSocket not connected. Cannot stop stream.');
                    console.warn('WebSocket not connected.');
                }
            });

            // Start YouTube Stream Button
            streamBtn.addEventListener('click', () => {
                appendLog('Starting YouTube live stream...');
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'startYouTubeStream' }));
                    streamBtn.disabled = true; // Disable while streaming
                } else {
                    appendLog('WebSocket not connected. Cannot start YouTube stream.');
                    console.warn('WebSocket not connected.');
                }
            });

            // Download Log Button
            downloadBtn.addEventListener('click', () => {
                appendLog('Preparing log for download...');
                const logContent = logDisplay.innerText;
                const blob = new Blob([logContent], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'ai_consciousness_log.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                appendLog('Log downloaded.');
            });

            // Fullscreen Button
            fullscreenBtn.addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                    appendLog('Exited fullscreen mode.');
                } else {
                    document.documentElement.requestFullscreen().then(() => {
                        appendLog('Entered fullscreen mode.');
                    }).catch(err => {
                        appendLog(`Error entering fullscreen: ${err.message}`);
                        console.error(`Error entering fullscreen: ${err}`);
                    });
                }
            });

            // Initialize debug mode display based on saved config (or default)
            if (localStorage.getItem('debugMode') === 'true') {
                debugModeInput.checked = true;
                debugInfo.style.display = 'block';
            } else {
                debugModeInput.checked = false;
                debugInfo.style.display = 'none';
            }
        });
    </script>
</body>
</html>
